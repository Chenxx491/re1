/*
冒泡排序：
    1. 将要排序的元素想象成一组从上往下的泡泡，排序时，分有序和无序两个区域；
    2. 开始排序的时候，有序区里只有1号泡泡，剩余泡泡在无序区；
    3. 从无序区中拿出2号泡泡与有序区的1号泡泡比较，若2号小于1号则两个泡泡交换，大于则不做交换；比较后的有序区里变成两个泡泡，其余在无序区
    4. 再从无序区拿出3号泡泡与有序区2号比较，小于2号则交换，交换后再与1号比较，小于1号则再交换；若与2比较时大于2号，则不做交换，本次排序完毕
    5. 此时有序区变为3个泡泡，再从无序区拿出4号泡泡与有序区中3号，2号，1号比较，重复第四步操作
    6. 如此循环直到无序区中的泡泡全部排序完毕
  列子：数组A = {5,2,6,3}进行冒泡排序
      1. 一开始有序区为[5]，无序区为[2,6,3]
      2. 无序区第一个元素2和有序区最后一个元素5比较，2 < 5；2和5交换，有序区变成[2,5]，无序区为[6,3]
      3. 无序区第一个元素6和有序区最后一个元素5比较，6 > 5；不交换，有序区变成[2,5,6]，无序区为[3]
      4. 无序区第一个元素3和有序区最后一个元素6比较，3 < 6；3和6交换；3再和有序区倒数第二个元素5比较，3 < 5，交换；再和下一个元素2比较
         3 > 2，不交换；有序区变成[2,3,5,6]，无序区为空，排序结束。
   算法时间复杂度：
       需要进行N-1趟排序，每趟排序需要和N-i个元素进行比较，所以时间复杂度为：O(N^2)
 */

public class ThreeKindsSort {
    // 冒泡排序
    public static void theBubbleSort(int[] ary){
        for (int i = 1; i < ary.length; i++) {
            for (int j = i; j > 0; j--) {
                if (ary[j]<ary[j-1]){
                    exchange(ary,ary[j],ary[j-1]);
                }
            }
        }
    }

    // 交换方法
    public static void exchange(int[] ary,int num1,int num2){
        int temp = num1;
        num1 = num2;
        num2 = temp;
    }
}